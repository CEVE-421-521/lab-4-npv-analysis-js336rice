---
title: "Lab 4: House Elevation NPV Analysis"
author: "Your Name"
jupyter: julia-1.10
date: 2024-02-08
week: 5
categories: [Lab]

format: 
    html: default

    # YOU DO NOT NEED BOTH PDF AND DOCX.
    # COMMENT OR DELETE THE ONE YOU DON'T WANT TO USE.
    pdf:
        documentclass: article
        fontsize: 11pt
        geometry:
            - margin=1in  
        number-sections: true
        code-line-numbers: true
    #docx: 
    #    toc: true
    #    fig-format: png
    #    number-sections: true
    #    code-line-numbers: true

# these are optional
# if you have cache=true, you'll need the jupyter-cache package installed
execute: 
  cache: true
  freeze: true

date-format: "ddd., MMM. D"
bibliography: references.bib
---

```{julia}
#| output: false
using CSV
using DataFrames
using DataFramesMeta
using Distributions
using Interpolations
using Plots
using StatsPlots
using Unitful

Plots.default(; margin=6Plots.mm)

include("depthdamage.jl")
```

Load in our data.
```{julia}
haz_fl_dept = CSV.read("data/haz_fl_dept.csv", DataFrame) # read in the file
desc = "one story, Contents, fresh water, short duration"
row = @rsubset(haz_fl_dept, :Description == desc)[1, :] # select the row I want
dd = DepthDamageData(row) # extract the depth-damage data
damage_fn = get_depth_damage_function(dd.depths, dd.damages) # get the depth-damage function

```

One should never pass up an opportunity to plot a graph.
```{julia}
p = let
    depths = uconvert.(u"ft", (-7.0u"ft"):(1.0u"inch"):(30.0u"ft"))
    damages = damage_fn.(depths)
    scatter(
        depths,
        damages;
        xlabel="Flood Depth",
        ylabel="Damage (%)",
        label="$(dd.description) ($(dd.source))",
        legend=:bottomright,
        size=(800, 400),
        linewidth=2,
    )
end
p
```

```{julia}
gauge_dist = GeneralizedExtremeValue(5, 1, 0.1) # hypothetical gauge distribution
offset = 7.5 # hypothetical height from house to gauge
flood_dist = GeneralizedExtremeValue(gauge_dist.μ - offset, gauge_dist.σ, gauge_dist.ξ)
```

```{julia}
elevation_cost = get_elevation_cost_function() # gives us a fitted interpolator
```

```{julia}
house_area = 1000u"ft^2"

heights = uconvert.(u"ft", (0u"ft"):(1u"inch"):(10u"ft")) # some heights we will consider
plot(
    heights,
    elevation_cost.(heights, house_area);
    xlabel="How High to Elevate",
    ylabel="Cost (USD)",
    label="$(house_area)",
    tiitle="Cost of Elevating a House",
)
```

Single Year Function:
```{julia}
function single_year_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh)
    
    # calculate the expected damages
    samples = rand(flood_dist, 100_000) .* 1u"ft"
    damages = damage_fn.(samples)
    expected_damages_pct = mean(damages)
 
    c_dmg = house_value * expected_damages_pct / 100

    # calculate the cost of elevating
    c_constr = elevation_cost(Δh, house_area)

    # return the total cost and benefit
    return -c_constr - c_dmg
end
```

```{julia}
house_area = 1000u"ft^2"
Δh = 10u"ft"
house_value = 250_000
c_constr = elevation_cost(Δh, house_area)


samples = rand(flood_dist, 100_000) .* 1u"ft"
damages = damage_fn.(samples)
expected_damages_pct = mean(damages)
print(expected_damages_pct, "\n")

c_dmg = house_value * expected_damages_pct / 100

print(c_dmg)
print("\n", c_constr)
```


```{julia}
house_area = 1000u"ft^2"
Δh = 10u"ft"
house_value = 250_000
single_year_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh)
```

```{julia}
function npv_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh, T, discount_rate)
    # calculate the costs and benefits for each year, and then discount
    # see above!
    npv = 0
    npv += single_year_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh)
    #print(npv)
    for year in 2:T
        Δh = 0u"ft"
        npv += single_year_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh) * ((1-discount_rate)^(year-1))
    end 
    # samples = rand(flood_dist, 100_000) .* 1u"ft"
    # damages = damage_fn.(samples)
    # expected_damages_pct = mean(damages)
    # expected_damages_usd = house_value * expected_damages_pct / 100
    
    # annual_damages = [expected_damages_usd for _ in 1:T] # annual expected damages
    
    # c_constr = elevation_cost(Δh, house_area)

    # npv = sum(annual_damages .* (1 - discount_rate) .^ (0:(T-1))) - c_constr 
    return npv
end
```

Let's make our single state of the world for a few actions
```{julia}
T = 10
discount_rate = 0.05
house_area = 1000u"ft^2"
house_value = 250_000
elevation_cost = get_elevation_cost_function() # gives us a fitted interpolator

gauge_dist = GeneralizedExtremeValue(5, 1, 0.1) # hypothetical gauge distribution
offset = 7.5 # hypothetical height from house to gauge
flood_dist = GeneralizedExtremeValue(gauge_dist.μ - offset, gauge_dist.σ, gauge_dist.ξ)

for i in range(start=0, stop=10, length=5)
    Δh = i * 1u"ft"
    println("For ", Δh)
    npv = npv_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh, T, discount_rate)
    println("NPV = ", npv)
end 
#Δh = 0u"ft"
#npv_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh, T, discount_rate)


```

For the given SOW of a house 7.5 ft above sea level, a discount rate of 5%, and the flooding and damage functions given, the higher we elevate the house, the lower our net present value.  THe cost of elevating is very high, and with the numbers how we have calcualted them, seems to not be worth it over a 10 year period.

