---
title: "Lab 4: House Elevation NPV Analysis"
author: "Your Name"
jupyter: julia-1.10
date: 2024-02-08
week: 5
categories: [Lab]

format: 
    html: default

    # YOU DO NOT NEED BOTH PDF AND DOCX.
    # COMMENT OR DELETE THE ONE YOU DON'T WANT TO USE.
    pdf:
        documentclass: article
        fontsize: 11pt
        geometry:
            - margin=1in  
        number-sections: true
        code-line-numbers: true
    #docx: 
    #    toc: true
    #    fig-format: png
    #    number-sections: true
    #    code-line-numbers: true

# these are optional
# if you have cache=true, you'll need the jupyter-cache package installed
execute: 
  cache: true
  freeze: true

date-format: "ddd., MMM. D"
bibliography: references.bib
---

```{julia}
#| output: false
using CSV
using DataFrames
using DataFramesMeta
using Distributions
using Interpolations
using Plots
using StatsPlots
using Unitful

Plots.default(; margin=6Plots.mm)

include("depthdamage.jl")
```

Load in our data.
```{julia}
haz_fl_dept = CSV.read("data/haz_fl_dept.csv", DataFrame) # read in the file
desc = "one story, Contents, fresh water, short duration"
row = @rsubset(haz_fl_dept, :Description == desc)[1, :] # select the row I want
dd = DepthDamageData(row) # extract the depth-damage data
damage_fn = get_depth_damage_function(dd.depths, dd.damages) # get the depth-damage function

```

One should never pass up an opportunity to plot an aesthetically pleasing graph.
```{julia}
p = let
    depths = uconvert.(u"ft", (-7.0u"ft"):(1.0u"inch"):(30.0u"ft"))
    damages = damage_fn.(depths)
    scatter(
        depths,
        damages;
        xlabel="Flood Depth",
        ylabel="Damage (%)",
        label="$(dd.description) ($(dd.source))",
        legend=:bottomright,
        size=(800, 400),
        linewidth=2,
    )
end
p
```

```{julia}
gauge_dist = GeneralizedExtremeValue(5, 1, 0.1) # hypothetical gauge distribution
offset = 7.5 # hypothetical height from house to gauge
flood_dist = GeneralizedExtremeValue(gauge_dist.μ - offset, gauge_dist.σ, gauge_dist.ξ)
```

```{julia}
elevation_cost = get_elevation_cost_function() # gives us a fitted interpolator
```

```{julia}
house_area = 1000u"ft^2"

heights = uconvert.(u"ft", (0u"ft"):(1u"inch"):(10u"ft")) # some heights we will consider
plot(
    heights,
    elevation_cost.(heights, house_area);
    xlabel="How High to Elevate",
    ylabel="Cost (USD)",
    label="$(house_area)",
    tiitle="Cost of Elevating a House",
)
```

Single Year Function:
```{julia}
function single_year_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh)
    
    # calculate the expected damages
    #h_dist = GeneralizedExtremeValue(flood_dist.μ - Δh.val, flood_dist.σ, flood_dist.ξ)
    #h_dist = flood_dist
    samples = rand(flood_dist, 100_000) .* 1u"ft"
    damages = damage_fn.(samples)
    #print(damages)
    expected_damages_pct = mean(damages)
    #println(expected_damages_pct)
 
    c_dmg = house_value * expected_damages_pct / 100

    # calculate the cost of elevating
    c_constr = elevation_cost(Δh, house_area)

    # return the total cost and benefit
    #println(c_constr)
    #println(c_dmg)
    return -c_constr - c_dmg
end
```


Test out our function: 
```{julia}
house_area = 1000u"ft^2"
Δh = 2.5u"ft"
house_value = 250_000
single_year_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh)

```

```{julia}
function npv_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh, T, discount_rate)
    # calculate the costs and benefits for each year, and then discount
    # see above!
    #h_dist = GeneralizedExtremeValue(flood_dist.μ - Δh.val, flood_dist.σ, flood_dist.ξ)
    npv = 0
    npv += single_year_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh)
    #print(npv)
    for year in 2:T
        Δh = 0u"ft"
        npv += single_year_cost_benefit(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh) * ((1-discount_rate)^(year-1))
    end 
    return npv
end
```

Let's make our single state of the world for a few actions
```{julia}
T = 10
discount_rate = 0.05
house_area = 1000u"ft^2"
house_value = 250_000


for i in range(start=0, stop=10, length=5)
    Δh = i * 1u"ft"
    println("For ", Δh)
    h_dist = GeneralizedExtremeValue(flood_dist.μ - Δh.val, flood_dist.σ, flood_dist.ξ)
    npv = npv_cost_benefit(h_dist, damage_fn, elevation_cost, house_area, house_value, Δh, T, discount_rate)
    println("NPV = ", npv)
end 



```

For the given SOW of a house 7.5 ft above sea level, a discount rate of 5%, and the flooding and damage functions given, the higher we elevate the house, the lower our net present value.  The cost of elevating is very high, and with the numbers how we have calcualted them, seems to not be worth it over a 10 year period.

Sensitivity test:

```{julia}
#let's start with 100 random samples for our discount rate:
rates = rand(Normal(0.05, 0.03), 10)

#Using the same state of the world as before:
T = 10

for i in range(start=0, stop=10, length=5)
    Δh = i * 1u"ft"
    println("For ", Δh)
    h_dist = GeneralizedExtremeValue(flood_dist.μ - Δh.val, flood_dist.σ, flood_dist.ξ)
    npvector = npv_cost_benefit.(h_dist, damage_fn, elevation_cost, house_area, house_value, Δh, T, rates)
    npv = mean(npvector)
    println("NPV = ", npv)
end 
#npv = npv_cost_benefit.(flood_dist, damage_fn, elevation_cost, house_area, house_value, Δh, T, rates)

#mean(npv)
```